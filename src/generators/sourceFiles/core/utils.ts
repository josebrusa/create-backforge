import fs from 'fs-extra';
import path from 'path';

export async function generateUtils(utilsDir: string): Promise<void> {
  // Logger will be generated by generateStructuredLogging in Phase 3
  // Generate a basic logger placeholder that will be replaced
  const loggerContent = `import winston from 'winston';
import { config } from '../config/env.js';
import fs from 'fs-extra';
import path from 'path';

// Ensure logs directory exists
const logsDir = path.join(process.cwd(), 'logs');
fs.ensureDirSync(logsDir);

const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

export const logger = winston.createLogger({
  level: config.NODE_ENV === 'production' ? 'info' : 'debug',
  format: logFormat,
  defaultMeta: { service: 'coreback-api' },
  transports: [
    new winston.transports.File({ filename: path.join(logsDir, 'error.log'), level: 'error' }),
    new winston.transports.File({ filename: path.join(logsDir, 'combined.log') }),
  ],
});

if (config.NODE_ENV !== 'production') {
  logger.add(
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    })
  );
}
`;

  await fs.writeFile(path.join(utilsDir, 'logger.ts'), loggerContent);

  // pagination.ts
  const paginationContent = `export interface PaginationOptions {
  page?: number;
  limit?: number;
}

export interface PaginationMeta {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

export interface PaginatedResponse<T> {
  data: T[];
  meta: PaginationMeta;
}

export function paginate<T>(
  data: T[],
  page: number = 1,
  limit: number = 10
): PaginatedResponse<T> {
  const total = data.length;
  const totalPages = Math.ceil(total / limit);
  const startIndex = (page - 1) * limit;
  const endIndex = startIndex + limit;
  const paginatedData = data.slice(startIndex, endIndex);

  return {
    data: paginatedData,
    meta: {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    },
  };
}

export async function paginateQuery<T>(
  queryFn: (skip: number, take: number) => Promise<{ data: T[]; total: number }>,
  page: number = 1,
  limit: number = 10
): Promise<PaginatedResponse<T>> {
  const skip = (page - 1) * limit;
  const { data, total } = await queryFn(skip, limit);
  const totalPages = Math.ceil(total / limit);

  return {
    data,
    meta: {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    },
  };
}
`;

  await fs.writeFile(path.join(utilsDir, 'pagination.ts'), paginationContent);

  // resource.ts
  const resourceContent = `export interface ResourceTransformer<T, R = T> {
  (data: T): R;
}

export class Resource<T, R = T> {
  constructor(
    private data: T | T[],
    private transformer?: ResourceTransformer<T, R>
  ) {}

  static make<T, R = T>(
    data: T | T[],
    transformer?: ResourceTransformer<T, R>
  ): Resource<T, R> {
    return new Resource(data, transformer);
  }

  toJSON(): R | R[] {
    if (Array.isArray(this.data)) {
      return this.data.map((item) =>
        this.transformer ? this.transformer(item) : (item as unknown as R)
      );
    }
    return this.transformer
      ? this.transformer(this.data)
      : (this.data as unknown as R);
  }

  static collection<T, R = T>(
    data: T[],
    transformer?: ResourceTransformer<T, R>
  ): R[] {
    return data.map((item) =>
      transformer ? transformer(item) : (item as unknown as R)
    );
  }

  static single<T, R = T>(
    data: T,
    transformer?: ResourceTransformer<T, R>
  ): R {
    return transformer
      ? transformer(data)
      : (data as unknown as R);
  }
}

export function transformResponse<T, R = T>(
  data: T | T[],
  transformer?: ResourceTransformer<T, R>
): R | R[] {
  if (Array.isArray(data)) {
    return data.map((item) =>
      transformer ? transformer(item) : (item as unknown as R)
    );
  }
  return transformer ? transformer(data) : (data as unknown as R);
}
`;

  await fs.writeFile(path.join(utilsDir, 'resource.ts'), resourceContent);
}
